# Why Is Real Not Really?

### Before Reading

相信在看过前几个专题以后，读者一定会发现笔者对英语双关钟爱有加（

本期题目最早设想了另一个更抖机灵的名字：**Why does double trouble?** 

因为太冷了把本人冻感冒了遂改名（改后也超冷的好吧



本篇是Existimer开发设计的第4篇。本篇不同于前面几篇，将尝试从数学和实验角度（~~因为数学不过关而被迫做实验~~）探讨列表排序算法，也是笔者自去年冬天以来，第一次深入讨论算法。本篇不会使用AI，因此语言可能更加生涩一点。



### Abstract

在任务列表、看板、协作文档等多种应用中，常常需要维护对象的顺序，并支持在任意位置插入或移动元素，而又不希望引入复杂的数据结构。常见的做法是为每个元素分配一个“顺序索引”（order index），插入或移动元素时仅更新相关索引，最终通过按索引排序来还原正确的排列顺序。

在这种设计中，**索引排序算法的选取决定了系统的整体可用性与性能表现**。优秀的索引排序算法能够在插入密度较高的情况下维持较低的重排频率，确保索引系统在长期运行中仍保持可用，同时将资源消耗控制在可接受范围内。

本文通过对比 **INT64 数值索引** 和 **FP64 浮点索引**，探讨了多种索引排序算法的适用性，聚焦于小规模顺序维护场景中的算法选择，并纠正了部分常见误解。同时，我们对 INT64 数索引进行了优化，拓展了其适用范围。

------

### Introduction

当前用于顺序维护的索引算法大致可分为三类：

1. **数值索引**（Numeric Indexing）
    使用整数或浮点数等具备自然大小关系的数据类型，实现顺序排序。该类方法实现简单、资源占用少，适用于轻量级、对精度要求不高的场景。然而，在频繁插入和重排的情形下，若缺乏有效策略以保持稀疏度或避免碰撞，极易导致重排频繁，进而带来性能开销，甚至反噬最初设计的简洁。
2. **字符索引**（Lexicographic Indexing）
    利用字符串类型进行排序，通常通过编码方式（例如 base62、二进制分级等）表示无限精度的数值。该方法突破了数值索引的类型位数限制，在理论上可支持无限次插入而无需重排。在现实实践中，字符索引最通用。为控制字符串长度的增长，该方法往往也需引入辅助机制，防止字符串无限扩张或整体重写。
3. **结构性索引**（Structure-based Indexing）
    如链表、跳表等数据结构，本质上通过指针关系维护元素顺序，天然支持高频插入与移动操作，且不存在精度损失问题。但由于其随机访问性能较差，不适合用于频繁读取的大型数据集，且与数据库等线性存储结构集成的代价较高，因此在多数场景下不被采用。