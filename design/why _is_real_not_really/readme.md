# Why Is Real Not Really?

### Before Reading

相信在看过前几个专题以后，读者一定会发现笔者对英语双关钟爱有加（

本期题目最早设想了另一个更抖机灵的名字：**Why does double trouble?** 

因为太冷了把本人冻感冒了遂改名（改后也超冷的好吧



这些分析对于Existimer的开发作用不大。但是Existimer本身作为一个学习性的项目，偶尔摘一下路边的野花也没什么不应该的。



本篇是Existimer开发设计的第4篇。本篇不同于前面几篇，本篇将尝试从数学和实验角度（~~因为数学不过关而被迫做实验~~）探讨列表排序算法，也是笔者自去年冬天以来，第一次深入讨论算法。本篇不会直接使用AI生成内容，因此语言可能更加生涩一点。

建议跳过概述和引言，考研复习累了闲暇里水的无营养文字就不要看了（捂脸

AI生成的省流一句话总结（~~喂刚刚不是说不用AI生成内容的么（~~：

> 通过分析 INT64 与 FP64 索引在高密度插入下的性能边界，结合路径编码及压缩存储技术，提出了一种支持2^63次最坏情况插入且兼顾空间效率的高性能顺序索引方案。

### Abstract

在任务列表、看板、协作文档等多种应用中，维护对象的顺序并支持在任意位置插入或移动元素，是常见且基础的需求。通常做法是为每个元素分配一个"顺序索引"（order index），插入或移动时仅调整相关索引，最终通过索引排序还原正确排列。

在这一设计中，**索引排序算法的选择直接影响系统的整体可用性和性能表现**。优秀的排序算法能够在高密度插入场景下保持低重排频率，确保索引系统长期稳定可用，同时将资源消耗控制在合理范围。

本文从对比 **INT64 整数索引** 与 **FP64 浮点索引** 出发，探讨多种索引排序算法的适用场景，纠正部分常见误解。特别指出，整数索引并非天生劣势，而是存在关键的"53位"间距这一"神秘数字"（~~其实不神秘一看就知道恰好是超出FP64的精度上限~~），使得在适当设计下，整数索引的性能和可用性可以接近甚至超越浮点索引。此外，结合类似 LexoRank 的字符索引方法，我们提出基于路径编码的排序方案，该方案可将路径编码压缩进单个 INT64，实现最坏情况下 $2^{63}$ 次插入操作；或利用 BLOB 存储方式，获得比字符串编码或 LexoRank 更优的性能表现。

### Introduction

顺序维护索引算法大致分为三类：

1. **数值索引（Numeric Indexing）**
    以整数或浮点数为基础，利用其天然大小关系完成排序。该类算法实现简洁，存储紧凑，适合轻量场景。但在高频插入下，若不能有效保持值的稀疏度，容易出现值碰撞和频繁重排，带来性能瓶颈。
2. **字符索引（Lexicographic Indexing）**
    通过字符串编码（如 base62、分级编码等）模拟无限精度的数值，理论上支持无限次插入而无需重排。字符索引的通用性极强，且天然支持分布式场景。但字符串长度增长需要控制，否则影响存储与查询性能，通常需配合辅助策略限制增长。
3. **结构性索引（Structure-based Indexing）**
    如链表、跳表等数据结构，依靠指针维护顺序，天然支持高频插入移动且不存在精度限制。但其随机访问性能差，且难以与数据库等线性存储系统高效整合，因而在多数场景不被采用。

在数值索引中，**整数（INT64）和浮点（FP64）是最主流的两种实现方式**。现实中，FP64索引因其能通过中间值计算支持较多插入而广泛使用，INT64索引则较少被采纳。一个普遍观点是"INT64不如FP64"，这其实是基于对两者特性的误解。

实际上，INT64索引的瓶颈常被认为是缺乏足够的中间可插入值，但这种观点却忽视了INT64极限精度大于FP64这一关键事实。利用大于2^53的初始间隔，INT64索引在小规模数据及适当插入密度下，表现出的插入容量和稳定性可远远超过FP64，且因整数操作精度无误差，整体更具确定性和效率。

结合对 LexoRank 等字符索引的研究，我们进一步提出基于**路径编码（Path Encoding）**的索引方法。该方法支持通过压缩编码，将路径信息存入单个INT64字段，理论上支持最坏情况下高达 $2^{63}$ 次插入操作，无需频繁重排。同时，若采用 BLOB 形式存储路径编码，则可利用数据库字节序排序的天然优势，获得相较于传统字符串编码或LexoRank更优的性能和空间表现。